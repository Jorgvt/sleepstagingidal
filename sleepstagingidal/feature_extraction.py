# AUTOGENERATED! DO NOT EDIT! File to edit: ../Notebooks/02_feature_extraction.ipynb.

# %% auto 0
__all__ = ['read_clean_edf', 'calculate_bandpower']

# %% ../Notebooks/02_feature_extraction.ipynb 6
from multiprocessing.spawn import import_main_path
import os
from glob import glob
from collections import Counter
from typing import List, Dict, Tuple

from rich.progress import track
import numpy as np
import pandas as pd
import mne
import yasa

from .data import *
from .dataa import *

# %% ../Notebooks/02_feature_extraction.ipynb 11
def read_clean_edf(path, # Path to an `.edf` file.
                   resample: int = None, # Frequency (Hz) we want to resample to. If `None`, no resampling is applied.
                   bandpass: Tuple[float, float] = None, # Tuple (min_freq, max_freq) for the bandpass filter. If `None`, no bandpass is applied.
                   verbose: bool = False, # Quantity of information to be shown.
                   ) -> mne.io.edf.edf.RawEDF: # `Raw` object with the corresponding cleaning,
    """Loads and (potentially) cleans an `.edf` file."""
    raw = mne.io.read_raw_edf(path, preload=False, verbose=verbose)
    if resample is not None: raw.resample(resample, verbose=verbose)
    if bandpass is not None: raw.filter(*bandpass, verbose=verbose)
    return raw

# %% ../Notebooks/02_feature_extraction.ipynb 15
def calculate_bandpower(epochs, # Epochs object or 3D array [Epochs, Channels, Data].
                        sf=100, # Sampling frequency of the data.
                        ) -> np.array: # Numpy array of shape [Epochs, 6*Channels] representing 6 bands.
    """Extracts the bandpower per epoch and returns it as an array ready to be fed into a model."""
    n_channels = len(epochs.ch_names) if isinstance(epochs, mne.epochs.Epochs) else epochs.shape[1]
    bandpowers = np.empty(shape=(len(epochs), 6*n_channels))
    for i, epoch in enumerate(epochs):
        df_bandpower = yasa.bandpower(epoch, sf=sf)
        df_bandpower.drop(['TotalAbsPow', 'Relative', 'FreqRes'], axis=1, inplace=True)
        df_bandpower = df_bandpower.to_numpy().flatten()
        if len(df_bandpower) != bandpowers.shape[-1]: raise ValueError("Shape mismatch between calculated features and pre-allocated array.")
        bandpowers[i] = df_bandpower
    return bandpowers
