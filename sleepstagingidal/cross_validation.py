# AUTOGENERATED! DO NOT EDIT! File to edit: ../Notebooks/03_cross_validation.ipynb.

# %% auto 0
__all__ = ['PatientFold']

# %% ../Notebooks/03_cross_validation.ipynb 5
import os
from glob import glob
from collections import Counter
from typing import List, Dict, Tuple

import numpy as np
import pandas as pd
from fastcore.basics import patch
from fastcore.foundation import L

from .data import *
from .dataa import *
from .dataa import swap_dict
from .feature_extraction import *

# %% ../Notebooks/03_cross_validation.ipynb 12
class PatientFold():
    """Manager to perform the so-called PatientFold."""
    def __init__(self,
                 path_files: List[str], # Path to the `.edf` files we want to use.
                 n_splits: int, # Number of folds to use.
                 random_state: int, # Random seed for reproducibility
                 ): 
        self.path_files = path_files
        self.n_splits = n_splits
        self.random_state = random_state
        self.folds = KFold(len(path_files))
        self._patients = None

# %% ../Notebooks/03_cross_validation.ipynb 14
@patch(as_prop=True)
def patients(self: PatientFold):
    """Ensures that the `.edf` files are only loaded and preprocessed once."""
    if self._patients is None:
        self._patients = L([read_clean_edf(path, resample=100, bandpass=(0.3, 49)) for path in track(self.path_files, description="Pre-processing recordings")])
    return self._patients

# %% ../Notebooks/03_cross_validation.ipynb 22
@patch
def fit(self: PatientFold,
        estimator, # Any object implementing a `.fit()` method to be crossvalidated. Must not be instantiated.
        **kwargs, # Key-word arguments to be passed to the estimator at instance time.
        ): # Results from the Patiend-Fold.
    """
    Performs the cross-validation loop by training the `estimator` on the different folds
    and returns the results.
    """
    results = {"train":[], "test":[], "model":[]}
    for train_idx, test_idx in self.folds.split(self.patients):
        ## Separate according to the indexes
        train_patients = self.patients[train_idx]
        test_patients = self.patients[test_idx]
        
        ## Build data
        X_train, Y_train = get_trainable_from_patients(train_patients, channels=channels, feature_extraction_fn=calculate_bandpower)
        X_test, Y_test = get_trainable_from_patients(test_patients, channels=channels, feature_extraction_fn=calculate_bandpower)

        ## Encode labels
        le = LabelEncoder()
        le.fit(Y_train)
        Y_train, Y_test = le.transform(Y_train), le.transform(Y_test)
        
        ## Train the model
        model = estimator(**kwargs, random_state=self.random_state)
        model.fit(X_train, Y_train)

        ## Obtain the metrics of interest
        results["train"].append(model.score(X_train, Y_train))
        results["test"].append(model.score(X_test, Y_test))
        results["model"].append(model)

    return results
